<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>新聞RSS人名標記工具</title>
<style>
  body { font-family: Arial, sans-serif; line-height: 1.6; }
  label { font-weight: bold; margin-right: 8px; }
  #controls { margin: 20px 0; }
  #progress-bar { width: 100%; background: #eee; border: 1px solid #ccc; height: 20px; margin-top: 5px; }
  #progress-bar-inner { background: #4caf50; width: 0%; height: 100%; }
  #progress-text { font-weight: bold; }
  #result { white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; height: 300px; overflow: auto; margin-top: 10px; font-family: Consolas, monospace; }
</style>
</head>
<body>

<h1>新聞 RSS 人名提取與標籤分類工具</h1>

<div id="controls">
  <div>
    <label for="timeRange">時間範圍:</label>
    <select id="timeRange">
      <option value="1">今日</option>
      <option value="3">近三日</option>
      <option value="7">一週內</option>
    </select>
  </div>
  <div>
    <label for="maxCount">最大新聞數量:</label>
    <input type="number" id="maxCount" value="50" min="1" style="width:80px;">
  </div>
  <div>
    <label for="delaySec">每則延遲秒數:</label>
    <input type="number" id="delaySec" value="0" min="0" style="width:80px;">
  </div>
  <button id="startBtn">開始擷取</button>
</div>

<div>
  <label>進度:</label>
  <span id="progress-text">0.00%</span>
  <div id="progress-bar">
    <div id="progress-bar-inner"></div>
  </div>
</div>

<div id="result" placeholder="擷取結果將顯示於此區域"></div>
<button id="downloadBtn" disabled>下載結果 (.txt)</button>

<script>
(() => {
  // RSS來源設定
  const feeds = [
    { name: "自由時報", url: "https://news.ltn.com.tw/rss/all.xml" },
    { name: "聯合報", url: "https://rsshub.app/udn/news/breakingnews/99" },
    { name: "TVBS",   url: "https://feeds.feedburner.com/Tvbs" },
    { name: "ETtoday", url: "https://feeds.feedburner.com/ettoday/realtime" },
    { name: "三立新聞", url: "https://rsshub.app/setn" }
  ];

  const startBtn = document.getElementById('startBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressText = document.getElementById('progress-text');
  const progressBarInner = document.getElementById('progress-bar-inner');
  const resultDiv = document.getElementById('result');
  const timeRangeSelect = document.getElementById('timeRange');
  const maxCountInput = document.getElementById('maxCount');
  const delaySecInput = document.getElementById('delaySec');

  // Helper: fetch RSS with fallback to proxy if needed
  async function fetchRSS(url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.text();
    } catch (err) {
      // Try using allOrigins proxy
      const proxyUrl = "https://api.allorigins.win/raw?url=" + encodeURIComponent(url);
      const res2 = await fetch(proxyUrl);
      if (!res2.ok) throw new Error("Proxy fetch failed for " + url);
      return await res2.text();
    }
  }

  // Helper: convert HTML entities to text and strip tags
  function htmlToText(html) {
    const div = document.createElement("div");
    div.innerHTML = html;
    return div.textContent || div.innerText || "";
  }

  startBtn.addEventListener('click', async () => {
    // Read and parse user inputs
    const days = parseInt(timeRangeSelect.value, 10);
    const maxCount = parseInt(maxCountInput.value, 10) || 0;
    const delaySec = parseFloat(delaySecInput.value) || 0;

    // Initialize UI
    startBtn.disabled = true;
    downloadBtn.disabled = true;
    resultDiv.textContent = "";  // clear previous results
    progressText.textContent = "0.00%";
    progressBarInner.style.width = "0%";

    // Prepare date threshold for filtering
    const now = new Date();
    const thresholdTime = now.getTime() - (days * 24 * 60 * 60 * 1000);

    // Fetch all feeds
    let allItems = [];
    for (const feed of feeds) {
      try {
        const xmlStr = await fetchRSS(feed.url);
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlStr, "text/xml");
        // Check parse errors
        if (xmlDoc.querySelector("parsererror")) {
          console.warn(`解析 ${feed.name} RSS 時出現錯誤`);
          continue;
        }
        // Select item or entry nodes
        let items = Array.from(xmlDoc.getElementsByTagName("item"));
        if (items.length === 0) {
          items = Array.from(xmlDoc.getElementsByTagName("entry"));
        }
        // Extract relevant fields from each item
        for (const item of items) {
          let title = item.getElementsByTagName("title")[0]?.textContent || "";
          let description = "";
          // Try multiple possible description/content tags
          const descNode = item.getElementsByTagName("description")[0] 
                        || item.getElementsByTagName("content:encoded")[0] 
                        || item.getElementsByTagName("content")[0] 
                        || item.getElementsByTagName("summary")[0];
          if (descNode) {
            description = descNode.textContent || "";
          }
          // Clean HTML from title/description
          title = htmlToText(title);
          description = htmlToText(description);
          // Get date
          let dateStr = "";
          const pubDateNode = item.getElementsByTagName("pubDate")[0] 
                           || item.getElementsByTagName("published")[0] 
                           || item.getElementsByTagName("updated")[0];
          if (pubDateNode) {
            dateStr = pubDateNode.textContent;
          }
          let pubTime = null;
          if (dateStr) {
            const d = new Date(dateStr);
            if (!isNaN(d.getTime())) {
              pubTime = d.getTime();
            }
          }
          // If date missing or invalid, we include by default (or skip? We'll include if no date since can't filter)
          if (pubTime === null) pubTime = now.getTime();
          // Filter by date range
          if (pubTime >= thresholdTime) {
            allItems.push({
              source: feed.name,
              title: title,
              description: description,
              time: pubTime
            });
          }
        }
      } catch (e) {
        // If a feed fails, log a warning in the results
        const errLine = `【${feed.name}】 RSS擷取失敗: ${e.message}`;
        console.warn(errLine);
        // Display error info in result area as well
        resultDiv.append(document.createTextNode(errLine));
        resultDiv.append(document.createElement("br"));
      }
    }

    if (allItems.length === 0) {
      const noDataMsg = "（沒有符合條件的新聞項目）";
      resultDiv.append(document.createTextNode(noDataMsg));
      resultDiv.append(document.createElement("br"));
      // Reset progress to 100%
      progressText.textContent = "100.00%";
      progressBarInner.style.width = "100%";
      startBtn.disabled = false;
      downloadBtn.disabled = false;
      return;
    }

    // Sort items by time (desc)
    allItems.sort((a, b) => b.time - a.time);
    // Apply max count limit
    if (maxCount > 0 && allItems.length > maxCount) {
      allItems = allItems.slice(0, maxCount);
    }

    const totalItems = allItems.length;
    const resultLines = [];  // to accumulate lines for download

    // Function to process one news item (extract names and labels)
    function processItem(item) {
      const contentText = (item.title ? item.title + "。" : "") + item.description;
      // Split content into sentences by punctuation (Chinese period, exclamation, question marks and line breaks)
      const sentences = contentText.split(/(?<=[。！？\n])/);
      // Define keywords and corresponding labels
      const labelMap = {
        "女警": "女警",
        "警花": "女警",
        "啦啦隊": "啦啦隊",
        "藝人": "藝人",
        "網紅": "網紅",
        "模特兒": "模特兒",
        "女星": "女星",
        "女立委": "女立委",
        "立委": "立委"
      };
      // Common Chinese surnames (for identifying names)
      const surnames = "陳林黃張李王吳劉蔡楊許鄭謝曾賴周呂柯沈丁洪侯方宋朱唐白高徐許馮鄧曹薛傅程魏蔣田杜袁阮邱金何胡施任";
      const namePattern = new RegExp(`([${surnames}][\\u4e00-\\u9fa5]{1,2})`, 'g');

      const nameData = {}; // object to accumulate info per name
      sentences.forEach((sentence) => {
        // Trim sentence and skip if very short
        const text = sentence.trim();
        if (!text) return;
        // Find any name candidates in the sentence
        const namesInSentence = text.match(namePattern);
        if (!namesInSentence) return;
        // Determine labels present in this sentence (if any of the keywords are present)
        const labelsInSentence = new Set();
        for (const [key, label] of Object.entries(labelMap)) {
          if (text.includes(key)) {
            labelsInSentence.add(label);
          }
        }
        // For each name found, update its record
        namesInSentence.forEach(name => {
          if (!nameData[name]) {
            nameData[name] = { labels: new Set(), context: text };
          }
          // If this sentence contains any label keywords and the name currently has no label context, update context to this sentence
          if (labelsInSentence.size > 0 && nameData[name].labels.size === 0) {
            nameData[name].context = text;
          }
          // Add any labels from this sentence to the name's label set
          labelsInSentence.forEach(label => {
            nameData[name].labels.add(label);
          });
        });
      });

      // Construct output lines for each name
      for (const [name, info] of Object.entries(nameData)) {
        // Determine label text (join multiple labels with comma, or "無標籤" if none)
        let labelText = "無標籤";
        if (info.labels.size > 0) {
          labelText = Array.from(info.labels).join(",");
        }
        const source = item.source;
        const context = info.context;
        const line = `${name}｜${labelText}｜${source}｜${context}`;
        resultLines.push(line);
        // Append to output display
        resultDiv.append(document.createTextNode(line));
        resultDiv.append(document.createElement("br"));
      }
    }

    // Process each news item sequentially with delay
    let processedCount = 0;
    for (const item of allItems) {
      processItem(item);
      processedCount++;
      // Update progress bar and text
      const percent = (processedCount / totalItems) * 100;
      progressText.textContent = percent.toFixed(2) + "%";
      progressBarInner.style.width = percent.toFixed(2) + "%";
      // Scroll output to bottom for new content visibility
      resultDiv.scrollTop = resultDiv.scrollHeight;
      // Delay if specified (and not the last item)
      if (delaySec > 0 && processedCount < totalItems) {
        await new Promise(res => setTimeout(res, delaySec * 1000));
      }
    }

    // Ensure progress is 100% at end
    progressText.textContent = "100.00%";
    progressBarInner.style.width = "100%";
    // Enable download button and re-enable start button
    startBtn.disabled = false;
    downloadBtn.disabled = false;
    // Prepare downloadable text blob
    downloadBtn.onclick = () => {
      const blob = new Blob([resultLines.join("\n")], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "RSS_擷取結果.txt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };
  });
})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>新聞人名擷取工具</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
    h1 { font-size: 1.5em; }
    .controls { margin-bottom: 1em; }
    label { margin-right: 0.5em; }
    select, input { margin-right: 1em; }
    #progressContainer { margin: 10px 0; }
    #progressBar { width: 100%; max-width: 300px; height: 20px; vertical-align: middle; }
    #progressText { margin-left: 10px; }
    #nameCountText { margin-left: 10px; }
    #output { white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; max-height: 400px; overflow-y: auto; }
    #downloadBtn { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>台灣新聞媒體人名擷取工具</h1>
  <div class="controls">
    <label>新聞時間區間：
      <select id="dateRange">
        <option value="1">今天</option>
        <option value="3">近三天</option>
        <option value="7">近一週</option>
      </select>
    </label>
    <label>最多擷取新聞篇數：<input type="number" id="maxNews" value="10" min="1"></label>
    <label>每則延遲秒數：<input type="number" id="delaySeconds" value="1" min="0"></label>
    <button id="startBtn">開始爬取</button>
  </div>
  <div id="progressContainer">
    <progress id="progressBar" value="0" max="100"></progress>
    <span id="progressText">0.00%</span>
    <span id="nameCountText">｜已擷取人名筆數：0</span>
  </div>
  <div id="output"></div>
  <button id="downloadBtn" disabled>下載結果</button>

  <script>
    // RSS來源設定
    const feeds = [
      { sourceName: "自由時報", url: "https://api.allorigins.win/raw?url=https://news.ltn.com.tw/rss/all.xml" },
      { sourceName: "聯合報", url: "https://api.allorigins.win/raw?url=https://rsshub.app/udn/news/breakingnews/99" },
      { sourceName: "ETtoday新聞雲", url: "https://api.allorigins.win/raw?url=https://feeds.feedburner.com/ettoday/newslist" }
    ];
    // 常見百家姓(單姓)列表，用於辨識人名開頭
    const surnameList = "陳林黃張李王吳劉蔡楊許鄭謝洪郭邱曾廖賴徐周葉蘇莊江呂何蕭羅高潘簡朱鍾游彭詹胡施沈余盧梁趙顏柯翁魏孫戴馬韓";
    // 用於擷取姓名及括號描述的正則表達式
    const namePattern = new RegExp("([" + surnameList + "][\u4e00-\u9fff]{1,2})", "g");
    const parenPattern = /([\u4e00-\u9fff]{2,4})（([^）]{1,6})）/g;
    // 前置描述中不應判定為描述的結尾字元集合（常見動詞/語氣詞）
    const disallowedSuffix = new Set("說稱指控為問批評籲斥責示出叫".split(""));

    // 監聽「開始爬取」按鈕
    document.getElementById("startBtn").addEventListener("click", async () => {
      const dateRange = parseInt(document.getElementById("dateRange").value, 10);
      const maxNews = parseInt(document.getElementById("maxNews").value, 10);
      const delaySeconds = parseFloat(document.getElementById("delaySeconds").value);
      const outputElem = document.getElementById("output");
      const progressBar = document.getElementById("progressBar");
      const progressText = document.getElementById("progressText");
      const nameCountText = document.getElementById("nameCountText");
      const downloadBtn = document.getElementById("downloadBtn");

      // 初始化UI
      outputElem.textContent = ""; 
      progressBar.value = 0;
      progressText.textContent = "0.00%";
      nameCountText.textContent = "｜已擷取人名筆數：0";
      downloadBtn.disabled = true;
      document.getElementById("startBtn").disabled = true;

      // 計算時間範圍的起始時間（以當天0點為基準）
      const now = new Date();
      const startTime = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (dateRange - 1));
      const startTimestamp = startTime.getTime();

      let totalItems = [];  //將所有需要處理的新聞項目收集於此
      for (const feed of feeds) {
        try {
          const res = await fetch(feed.url);
          const xmlText = await res.text();
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlText, "text/xml");
          const items = Array.from(xmlDoc.querySelectorAll("item"));
          for (const item of items) {
            // 提取 pubDate 判斷時間
            const pubDateText = item.querySelector("pubDate")?.textContent || item.querySelector("pubDate")?.innerText || "";
            let pubTime = 0;
            if (pubDateText) {
              const pubDate = new Date(pubDateText);
              pubTime = pubDate.getTime();
            }
            // 若無法解析pubDate或在範圍內，則視為需要抓取
            if (!pubTime || pubTime >= startTimestamp) {
              const linkElem = item.querySelector("link");
              const link = linkElem ? linkElem.textContent || linkElem.innerText : "";
              if (link) {
                totalItems.push({ link: "https://api.allorigins.win/raw?url=" + encodeURIComponent(link), source: feed.sourceName });
              }
            }
            if (totalItems.length >= maxNews) break;
          }
        } catch (e) {
          console.error("抓取 RSS 失敗：", feed.sourceName, e);
        }
        if (totalItems.length >= maxNews) break;
      }

      // 限制總抓取篇數不超過maxNews
      if (totalItems.length > maxNews) {
        totalItems = totalItems.slice(0, maxNews);
      }

      let nameRecords = [];   // 收集所有姓名記錄，用於下載
      let namesFoundCount = 0;
      for (let i = 0; i < totalItems.length; i++) {
        const { link, source } = totalItems[i];
        try {
          // 延遲抓取
          if (i > 0 && delaySeconds > 0) {
            await new Promise(resolve => setTimeout(resolve, delaySeconds * 1000));
          }
          const res = await fetch(link);
          const htmlText = await res.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(htmlText, "text/html");
          // 抓取正文文字內容（取所有<p>文字）
          let contentText = "";
          const paragraphs = doc.querySelectorAll("p");
          if (paragraphs.length > 0) {
            contentText = Array.from(paragraphs).map(p => p.innerText).join("\n");
          } else {
            // 若沒有<p>，退而求其次用全文text
            contentText = doc.body ? doc.body.innerText : "";
          }
          if (!contentText) continue;
          // 提取人名與描述
          let articleNames = new Map();  // 用Map儲存可保持插入順序，也方便避免重複
          // 1. 括號模式
          contentText.replace(parenPattern, (_, name, desc) => {
            articleNames.set(name, desc);
            return _;  // replace不真正修改字符串
          });
          // 2. 前置描述模式（先處理特殊括號情況）
          const prefixScanText = contentText.replace(/（[^）]*）(?=[\u4e00-\u9fff])/g, "");
          let match;
          namePattern.lastIndex = 0;
          while ((match = namePattern.exec(prefixScanText)) !== null) {
            const fullName = match[1];
            if (articleNames.has(fullName)) continue;
            const idx = match.index;
            if (idx === 0) continue;
            const prevChar = prefixScanText[idx - 1];
            if (/[，。、：「」“”《》！？\(\)\s]/.test(prevChar)) {
              // 前一字元是標點或空白，視為無緊連描述
              continue;
            }
            // 從姓名開頭往前找連續的中文字符片段作為描述
            let j = idx - 1;
            while (j >= 0) {
              const ch = prefixScanText[j];
              if (/[，。、：「」“”《》！？\(\)\s]/.test(ch)) break;
              if (/[\u4e00-\u9fff]/.test(ch)) {
                j--;
                continue;
              }
              break;
            }
            const prefixChunk = prefixScanText.substring(j + 1, idx);
            if (!prefixChunk || prefixChunk.length > 8) continue;
            if (prefixChunk.includes("的")) continue;
            const lastChar = prefixChunk[prefixChunk.length - 1];
            if (disallowedSuffix.has(lastChar)) continue;
            articleNames.set(fullName, prefixChunk);
          }
          // 將本篇文章擷取到的所有人名條目輸出
          for (let [name, desc] of articleNames) {
            namesFoundCount++;
            const line = `${name} ${desc} ${source}`;
            nameRecords.push(line);
            outputElem.textContent += line + "\n";
          }
        } catch (e) {
          console.error("擷取新聞失敗：", link, e);
        }
        // 更新進度
        const progress = ((i + 1) / totalItems.length) * 100;
        progressBar.value = progress;
        progressText.textContent = progress.toFixed(2) + "%";
        nameCountText.textContent = "｜已擷取人名筆數：" + namesFoundCount;
      }

      document.getElementById("startBtn").disabled = false;
      downloadBtn.disabled = false;
    });

    // 監聽「下載結果」按鈕
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const content = document.getElementById("output").innerText;
      const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "names.txt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
